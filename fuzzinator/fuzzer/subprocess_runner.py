# Copyright (c) 2016-2020 Renata Hodovan, Akos Kiss.
#
# Licensed under the BSD 3-Clause License
# <LICENSE.rst or https://opensource.org/licenses/BSD-3-Clause>.
# This file may not be copied, modified, or distributed except
# according to those terms.

import logging
import os
import shutil
import subprocess

from ..config import as_bool, as_dict, as_pargs, as_path
from .. import Controller

logger = logging.getLogger(__name__)


class SubprocessRunner(object):
    """
    Wrapper around a fuzzer that is available as an executable and can generate
    its test cases as file(s) in a directory. First, the external executable is
    invoked as a subprocess, and once it has finished, the contents of the
    generated files are returned one by one.

    **Mandatory parameters of the fuzzer:**

      - ``command``: string to pass to the child shell as a command to run (all
        occurrences of ``{uid}`` in the string are replaced by an identifier
        unique to this fuzz job).
      - ``outdir``: path to the directory containing the files generated by the
        external fuzzer (all occurrences of ``{uid}`` in the path are replaced
        by the same identifier as described at the ``command`` parameter).

    **Optional parameters of the fuzzer:**

      - ``cwd``: if not ``None``, change working directory before the command
        invocation.
      - ``env``: if not ``None``, a dictionary of variable names-values to
        update the environment with.
      - ``timeout``: run subprocess with timeout.
      - ``contents``: if it's true then the content of the files will be returned
         instead of their path (boolean value, True by default).

    **Example configuration snippet:**

        .. code-block:: ini

            [sut.foo]
            # see fuzzinator.call.*

            [fuzz.foo-with-bar]
            sut=foo
            fuzzer=fuzzinator.fuzzer.SubprocessRunner
            batch=50

            [fuzz.foo-with-bar.fuzzer.init]
            outdir=${fuzzinator:work_dir}/bar/{uid}
            command=barfuzzer -n ${fuzz.foo-with-bar:batch} -o ${outdir}
    """

    def __init__(self, outdir, command, cwd=None, env=None, timeout=None, contents=True, **kwargs):
        # uid is used to make sure we create unique directory for the generated test cases.
        self.uid = '{pid}-{id}'.format(pid=os.getpid(), id=id(self))

        self.outdir = as_path(outdir.format(uid=self.uid))
        self.command = as_pargs(command.format(uid=self.uid))
        self.cwd = as_path(cwd) if cwd else os.getcwd()
        self.env = dict(os.environ, **as_dict(env)) if env else None
        self.timeout = int(timeout) if timeout else None
        self.contents = as_bool(contents)
        self.tests = []

    def __enter__(self):
        os.makedirs(self.outdir, exist_ok=True)
        try:
            proc = subprocess.Popen(self.command,
                                    cwd=self.cwd,
                                    env=self.env,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            stdout, stderr = proc.communicate(timeout=self.timeout)
            if proc.returncode != 0:
                logger.warning('Fuzzer command returned with nonzero exit code (%d).\n%s\n%s', proc.returncode,
                               stdout.decode('utf-8', errors='ignore'),
                               stderr.decode('utf-8', errors='ignore'))
        except subprocess.TimeoutExpired:
            logger.debug('Timeout expired in the fuzzer\'s subprocess runner.')
            Controller.kill_process_tree(proc.pid)
        self.tests = [os.path.join(self.outdir, test) for test in os.listdir(self.outdir)]
        return self

    def __exit__(self, *exc):
        shutil.rmtree(self.outdir, ignore_errors=True)
        return False

    # Although kwargs is not used here but the 'index' argument will be passed anyhow
    # and it has to be accepted.
    def __call__(self, **kwargs):
        if not self.tests:
            return None

        test = self.tests.pop()
        if not self.contents:
            return test

        with open(test, 'rb') as f:
            return f.read()
